---
layout: post
title: (ì „ê³µ ì„œì  ê³µë¶€) Stacks, Queues, and Deques
subtitle: Exercise-6
category: Studies
tags: [Algorithm]
---

â€œ ìŠ¤íƒ, í, ë°í¬ ADT (Abstract Data Type) ê·¸ë¦¬ê³  Python ëª¨ë“ˆâ€

# Lecture 6 - Stacks, Queues, and Deques

### 1. Stacks

A stack is **a collection of objects** that are inserted and removed according to the **last-in, first-out (LIFO) principle.**

â†’ ìŠ¤íƒì€ LIFO ì •ì±…ì„ ê°–ê³  ìˆëŠ” ê°ì²´ë“¤ì˜ ì§‘í•©ì´ë‹¤. 

â†’ ìœ ì €ëŠ” ìŠ¤íƒì˜ ê°ì²´ë“¤ì„ ì•„ë¬´ë•Œë‚˜ ì‚½ì…ì´ ê°€ëŠ¥í•˜ì§€ë§Œ ì‚½ì…ëœ ê°ì²´ì— ì ‘ê·¼í•˜ê±°ë‚˜ ì œê±°í•˜ê¸° ìœ„í•´ì„œëŠ” ì•ì„œ ë§í•œ ì •ì±…ì„ ë”°ë¼ì•¼í•œë‹¤. ì†Œìœ„ ë§í•´ â€œtopâ€ì—ì„œë§Œ ì ‘ê·¼ì´ ê°€ëŠ¥í•œ ê²ƒì´ë‹¤. 

â†’ ì¸í„°ë„· ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ í˜ì´ì§€ ì°½ì˜ ë’¤ë¡œê°€ê¸° ë“±ì˜ ê¸°ëŠ¥ì€ ìŠ¤íƒì˜ ì •ì±…ì„ ì‚¬ìš©í•œë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤. ë’¤ë¡œê°€ê¸° ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë°”ë¡œ ì´ì „ í˜ì´ì§€ê°€ popë˜ëŠ”ê²ƒì´ë‹¤. 

- The Stack Abstract Data Type

ìŠ¤íƒì˜ ì¶”ìƒí™” ë°ì´í„° íƒ€ì…ì¸ ì˜ˆë¥¼ë“¤ì–´ S (instance)ëŠ”ë‹¤ìŒê³¼ ê°™ì€ methodsë“¤ì„ ì§€ì›í•œë‹¤. 

- S
    
      S.push(e) : element eë¥¼ stack Sì˜ topì— ë”í•œë‹¤. 
    
      S.pop() : top elementë¥¼ ë°˜í™˜í•˜ê³  ì´ë¥¼ì œê±°í•œë‹¤. (is empty ì‹œ error)
    
      S.top() : Sì˜ topì˜ a reference element ë¥¼ ë°˜í™˜í•œë‹¤.  (is empty ì‹œ error)
    
      S.is_empty() : Sê°€ ì•„ë¬´ëŸ° elementë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šë‹¤ë©´ True ë¥¼ ë°˜í™˜í•œë‹¤.
    
      len(S) : 
    

- Simple Array-Based Stack Implementation

- Implementing a Stack Using a Python List

```python
class ArrayStack:
	def __init__(self):
		self._data = [] # empty python list for internal storage.
		
	def __len__(self):
		return len(self._data)
	
	def is_empty(self):
		return len(self._data) == 0

	def push(self, e):
		self._data.append(e)

	def top(self):
		if self.is_empty():
			raise Empty("Empty stack!")
		return self._data[-1]
	
	def pop(self):
		if self.is_empty():
			raise Empty("Empty stack!")
		return self._data.pop()
```

- Analyzing the Array-Based Stack Implementation

![Untitled]({{site.url}}/images/lecture6/Untitled.png)

â†’ Array-based stackì—ì„œëŠ” ê° ë©”ì„œë“œê°€ ìƒìˆ˜ ì‹œê°„ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤. ë‹¤ë§Œ push ê·¸ë¦¬ê³  popì˜ ê¸°ëŠ¥ì€ amortized analysisìƒ list classë‘ ë¹„ìŠ·í•œ boundsë¥¼ ê°€ì§€ê²Œ ë˜ê³ , pushë¥¼ ì–´ë””ì„œ ì–´ë–»ê²Œ í•˜ëŠëƒì— ë”°ë¼ $O(n)$ê¹Œì§€ë„ ìµœì•…ì˜ ê²½ìš° ê°€ì§ˆ ìˆ˜ ìˆë‹¤. ì´ëŠ” popë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤. 

**1.3 Reversing Data Using a Stack**

- Stackì€ìˆœì„œ ìˆëŠ” ë°ì´í„°ë¥¼ ë’¤ì§‘ì„ ë•Œ ì‚¬ìš©í•˜ëŠ”ë° ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.

**1.4 Matching Parentheses and HTML Tags**

â€¢ Parentheses: â€œ(â€ and â€œ)â€
â€¢ Braces: â€œ{â€ and â€œ}â€
â€¢ Brackets: â€œ[â€ and â€œ]â€

```python
def is_matched(expr): # ëª¨ë‘ ë§¤ì¹­ì— ì„±ê³µí•˜ë©´ Trueë¥¼ ë°˜í™˜í•œë‹¤. ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš° False.
	left_group = "({["
	right_group = ")}]"
	S = ArrayStack()
	for c in expr:
		if c in left_group:
			S.push(c)
		elif c in right_group:
			if S.is_empty():
				return False 
			item = S.pop() # itemì„ êº¼ë‚´ê¸° ì´ì „ Sì´ ë¹„ì–´ìˆëŠ”ì§€ í•­ìƒ í™•ì¸ë¶€í„° í•œë‹¤.
			if right_group.index(c) != left_group.index(item) : return False
	return S.is_empty() 
# stackì´ ë¹„ì–´ìˆë‹¤ë©´ ëª¨ë“  left_groupì´ êº¼ë‚´ì ¸ì„œ right_groupê³¼ ê²€ì‚¬í•œ ì…ˆì´ ë˜ë¯€ë¡œ 
# Maching delimitersì— ì„±ê³µí•œë‹¤. 
	
```

- ì›ë¦¬ëŠ” ê°„ë‹¨í•˜ë‹¤, left groupê³¼ right groupì„ ë‚˜ëˆ ì„œ left ê·¸ë£¹ì„ ìˆœì„œëŒ€ë¡œ ìŠ¤íƒì— ë„£ëŠ”ë‹¤. ê·¸ëŸ° ë‹¤ìŒ right ê·¸ë£¹ì´ ë“±ì¥í•˜ë©´ í•˜ë‚˜ì”© êº¼ë‚´ì„œ ì§ì´ ë§ëŠ”ì§€ ê²€ì‚¬í•œë‹¤.

### 2. Queues

The queue abstract data type defines a collection that keeps objects in a
sequence, where **element access and deletion are restricted to the first element in the queue**, and **element insertion is restricted to the back of the sequence.**

â†’ ì´ì— ëŒ€í•œ ì •ì˜ë¥¼ ìì„¸íˆ ì½ì–´ë³´ë©´  Queueë¼ëŠ” ìë£Œ êµ¬ì¡°ëŠ” ì—­ì‹œ ì‹œí€€ìŠ¤ ê°ì²´ë“¤ì— ëŒ€í•œ ì§‘í•©ì²´ì— ëŒ€í•´ ì •ì˜í•œ ê²ƒì´ë©°, ê° ì›ì†Œë“¤ì€ ì²«ë²ˆì§¸(first) ë˜ëŠ” ë§ˆì§€ë§‰ (back)ì—ì„œ ì ‘ê·¼ì´ë‚˜ ì‚­ì œê°€ í—ˆìš©ë˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì´ë ‡ê²Œ ì•, ë’¤ë¡œ ìë£Œì˜ ì‚½ì… ì‚­ì œê°€ ê°€ëŠ¥í•˜ë©° ë¨¼ì € ë“¤ì–´ì˜¨ ì›ì†Œê°€ ë¨¼ì € ë‚˜ê°€ëŠ” ì •ì±…ì„ ê°€ì ¸ First-in, first-out FIFO ë¼ê³  ë¶ˆë¦°ë‹¤. 

- Q
    
    enqueue(e) :  Qì˜ ë’¤ì— ì›ì†Œ eë¥¼ ë”í•œë‹¤. 
    
    dequeue() : Qì—ì„œ ì›ì†Œë¥¼ ì œê±°í•˜ê³  ì²«ë²ˆì§¸ ì›ì†Œë¥¼ ë°˜í™˜í•œë‹¤. Qê°€ ë¹„ì–´ìˆì„ ê²½ìš° ì—ëŸ¬ë¥¼ ì¼ìœ¼í‚¨ë‹¤. 
    
    first() : Qì— ì•ì— ìˆëŠ” ì›ì†Œë¥¼ ë°”ë…¸í•œí•œë‹¤. (ì œê±°ë˜ì§„ ì•ŠëŠ”ë‹¤.) 
    
    is_empty() : Qê°€ ë¹„ì–´ìˆëŠ” ê²½ìš° Trueë¥¼ ë°˜í™˜í•œë‹¤. 
    
    len() : Qì•ˆì˜ ì›ì†Œì˜ ìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤. íŒŒì´ì¬ì˜ ê²½ìš° special methodì¸ **len**ìœ¼ë¡œ êµ¬í˜„í•˜ì˜€ë‹¤.
    

**2.2 Array-Based Queue Implementation**

- íŒŒì´ì¬ list clasë¥¼ ì´ìš©í•´ì„œ ì†ì‰½ê²Œ simpleí•œ adapter classë¥¼ ë§Œë“¤ì–´ë³¼ ìˆ˜ ìˆë‹¤. enqueueì™€ dequeue ëŠ” append ê·¸ë¦¬ê³  popìœ¼ë¡œ ëŒ€ì¹˜ëœë‹¤.
- Chapter 5ì—ì„œ ë‹¤ë¤˜ë˜ ê²ƒê³¼ ê°™ì´ listì—ì„œ pop(e) ì˜ ê²½ìš°, íŠ¹íˆ pop(0)ë¥¼ í•˜ê²Œ ë˜ëŠ” ê²½ìš° worst-case behaviorê°€ $\Theta(n)$ ë¡œ ë§‰ì„ ìˆ˜ ì—†ë‹¤.
- ë”°ë¼ì„œ ë³¸ ì±…ì—ì„œëŠ” dequeí•˜ëŠ” ê²½ìš° Noneì„ ì°¸ì¡°í•˜ê²Œ í•˜ê³ , explicit variable fê°€ Qì˜ frontë¥¼ í•­ìƒ ê°€ë¦¬í‚¤ë„ë¡ í•˜ì—¬ $O(1)$ì˜ ì‹œê°„ì„ ë³´ì¥í•œë‹¤.
- ë‹¤ë§Œ ì´ ì ‘ê·¼ë²•ì€ më²ˆ ë§Œí¼ì˜ enque í¬ê¸°ë¥¼ ê°–ê²Œí•˜ì—¬  ì‚¬ì´ì¦ˆê°€ $O(m)$ ê°€ ë˜ê³ , element ìˆ˜ë§Œí¼ ì´ë¥¼ ì €ì¥í•˜ëŠ” ìŠ¤íƒê³¼ ë‹¤ë¥´ê²Œ ê³µê°„ì„ ë§ì´ ì°¨ì§€í•˜ê²Œ ëœë‹¤.

**Using an Array Circularly**

- ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê³  ì¢€ ë” ê°•ê±´í•œ Që¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œ, Qì˜ ì•ì´ ë‹¤ì‹œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì˜®ê²¨ì§€ë„ë¡ í•˜ëŠ” ë°©ë²•ì„ ì“°ë ¤ê³ í•œë‹¤.

![Untitled]({{site.url}}/images/lecture6/Untitled 1.png)

- Cricularlyí•œ í˜•íƒœì˜ queueë¥¼ ë§Œë“œëŠ” ê²ƒì´ë‹¤. ì´ë ‡ê²Œ ë˜ë©´ ë”± í•„ìš”í•œ ê³µê°„ë§Œí¼ë§Œ ì“¸ ìˆ˜ ìˆë‹¤. f = 0ìœ¼ë¡œ ê³ ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ f = (f+1) % N ìœ¼ë¡œ ë‘ë©´ ëœë‹¤.
    - ì˜ˆë¥¼ ë“¤ì–´, size 10ì¸ f = 0ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” queueê°€ ìˆë‹¤ê³  ìƒê°í•´ë³´ì, ì ˆëŒ€ì ì¸ ê³µê°„ë„ 10ìœ¼ë¡œ ì œí•œí•˜ì—¬ ì €ì¥í•˜ëŠ” queueì´ë‹¤. ì—¬ê¸°ì„œ 3ë²ˆì„ dequeueë¥¼ í•˜ë ¤ê³ í•˜ë©´ sizeëŠ” 7ì´ëœë‹¤. ê·¸ë¦¬ê³  fëŠ” (0+1) % 10 â†’  (1+1) % 10 â†’ (2+1) % 10  3ì´ ëœë‹¤.

**Adding and Removing Elements**

- ì´ëŸ° í˜•íƒœëŠ”, ì œí•œëœ ì‚¬ì´ì¦ˆ 10ì„ ë„˜ì–´ê°ˆ ë•Œ íŠ¹ì§•ì„ ë”ìš± ì˜ ì‚´í´ë³¼ ìˆ˜ ìˆë‹¤.
    
    ì˜ˆë¥¼ ë“¤ì–´ frontê°€ 8ì´ê³  3ê°œì˜ elementê°€ ì¡´ì¬ í•  ë•Œ, ì‚½ì…ë  ìœ„ì¹˜ëŠ” (8+3) % 10 11% 10 â†’ **1.**
    
    - 1ì˜ ìë¦¬ì— ìƒˆë¡œìš´ ì›ì†Œ eë¥¼ ì‚½ì…í•œë‹¤.

- Python Queue Implementation

```python
from queue import Empty
class ArrayQueue:
    DEFAULT_CAPACITY = 10
    
    def __init__(self):
        self._data = [None] * ArrayQueue.DEFAULT_CAPACITY
        self._size = 0
        self._front = 0

    def __len__(self):
        return len(self._size)
    
    def __str__(self):
        return str(self._data)

    def is_empty(self):
        return self._size == 0

    def first(self):
        if self.is_empty():
            raise Empty("Queue is empty.")
        return self._data[self._front]

    def enqueue(self,e):
        if self._size == len(self._data):
            self._resize(2*len(self._data)) # insert index
        avail = (self._front + self._size) % len(self._data) 
        self._data[avail] = e
        self._size +=1
        return 

    def dequeue(self):
        if self.is_empty():
                raise Empty("Queue is empty.")	 # Empty class 
        item = self._data[self._front]
        self._data[self._front] = None
        self._front = (self._front + 1) % len(self._data)
        self._size -=1
        
        if 0 < self_size < len(self._data) //4 :
            self._resize(len(self._data) //2)
        return item

    def _resize(self, cap):
        old = self._data
        self._data = [None] * cap 
        walk = self._front
        for k in range(self._size):
            self._data[k] = old[walk]
            walk = (1+ walk) % len(old)
        self._front = 0

```

[queue - A synchronized queue class - Python 3.10.5 documentation](https://docs.python.org/ko/3.7/library/queue.html#queue.Empty)

- _front ë³€ìˆ˜ëŠ” í˜„ì¬ íì˜ ì²«ë²ˆì§¸ ì›ì†Œë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•˜ê³  ìˆë‹¤.
- _sizeëŠ” í˜„ì¬ ì›ì†Œê°€ ì¡´ì¬í•˜ëŠ” ê°œìˆ˜(í˜„ì¬ ë“¤ì–´ ìˆëŠ” ì›ì†Œì˜ ì¸ë±ìŠ¤ì˜ +1)ë¥¼ ì €ì¥í•˜ê³  ìˆëŠ” ë³€ìˆ˜ì´ë‹¤.

### 3 Double-Ended Queues

**â€œQueue-like data structure that supports insertion and deletion at both the front and the back of the queue.â€**

â†’ í ìë£Œêµ¬ì¡°ëŠ” First In First Out ì´ë¼ëŠ” ì •ì±…ì— ë§ê²Œ, ë°ì´í„°ê°€ ë‚˜ê°€ëŠ” ë°©í–¥ì´ ì•ìœ¼ë¡œ ì •í•´ì ¸ìˆë‹¤. Double-ended Queueì˜ ê²½ìš° ì´ì™€ ë‹¤ë¥´ê²Œ ë°ì´í„°ì˜ ì‚½ì…ê³¼ ì‚­ì œë¥¼ ì•, ë’¤ ëª¨ë‘ ì§€ì›í•˜ë©° ì´ëŸ¬í•œ êµ¬ì¡°ì˜ íŠ¹ì„± ë•Œë¬¸ì— ì•ì„  ì´ë¦„ì´ ë¶™ì—ˆë‹¤.  ë‹¤ë¥¸ ë§ë¡œ ***deque*** ë°í¬ë¼ê³ ë„ ë¶€ë¥¸ë‹¤. 

dequeì˜ í•„ìš”ì„±ê³¼ ê´€ë ¨í•´ì„œ ì„œì ì—ëŠ” ë ˆìŠ¤í† ë‘ì—ì„œ ì†ë‹˜ì„ ê´€ë¦¬í•˜ëŠ” ê²ƒì— ê·¸ ë¹„ìœ ë¥¼ ë“¤ê³  ìˆëŠ”ë°, ì²« ë²ˆ ì§¸ ì‚¬ëŒì´ ì´ìš© ê°€ëŠ¥í•œ í…Œì´ë¸”ì´ ì—†ì–´ì„œ ì œê±°ë˜ì—ˆë‹¤ê°€ ë‹¤ì‹œ ì•ì— ì¶”ê°€ë  ìˆ˜ ìˆê³  ë§ˆì§€ë§‰ ì†ë‹˜ì´ ê¸°ë‹¤ë¦¬ì§€ ëª»í•˜ê³  ê·¸ëƒ¥ ë‚˜ê°€ê²Œ ë  ìˆ˜ë„ ìˆë‹¤. ì´ë ‡ê²Œ ì¢€ ë” generalí•œ data structureì— ëŒ€í•´ì„œ ì´ì•¼ê¸°ë¥¼ í•˜ê³  ìˆë‹¤. 

3-1 The Deque Abstract Data Type

![Untitled]({{site.url}}/images/lecture6/Untitled 2.png)

- ê¸°ë³¸ì ì¸ ê¸°ëŠ¥, ì‹œì‘ê³¼ ëì—ì„œ ë”í•˜ê³ (add) ì œê±°í•˜ëŠ”(delete) ë©”ì„œë“œë¥¼ ì§€ì›í•˜ê³  ìˆë‹¤. ë™ì‹œì— accessor ë˜í•œ ì§€ì›í•˜ëŠ”ë° ì²˜ìŒê³¼ ë§ˆì§€ë§‰ì„ ê°€ë¦¬í‚¤ê³  ìˆì–´ ê·¸ ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ê³¼ ì´ë¥¼ í†µí•´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” is_emptyì™€ ê·¸ ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ëŠ” len ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

**Resizing the Queue**

- enqueue ì‹œ, ì‚¬ì´ì¦ˆê°€ ë°ì´í„° ì €ì¥ê³µê°„ê³¼ ê°™ì•„ì§€ê²Œ ë˜ëŠ” ê²½ìš° 5.3.1ì˜ DynamicArrayì—ì„œ êµ¬í˜„í–ˆë˜ ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ ì €ì¥ ê³µê°„ì„ ë‘ ë°°ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ë³´í¸ì ì¸ í…Œí¬ë‹‰ì„ ì§„í–‰í•˜ê²Œ ëœë‹¤.
- ì´ ë•Œ, ê³µê°„ì„ ëŠ˜ë¦¬ê³  ë‹¤ì‹œ ì»¨í…ì¸ ë“¤ì„ transferí•˜ëŠ” ì‘ì—…ì„ í•˜ê²Œ ë˜ëŠ”ë° ì¬í• ë‹¹í•˜ëŠ” ê³¼ì •ì—ì„œ frontê°€ 0ìœ¼ë¡œ ë‹¤ì‹œ ì„¤ì •í•´ì£¼ê²Œ ëœë‹¤.

![Untitled]({{site.url}}/images/lecture6/Untitled 3.png)

**Shrinking the Underlying Array**

- ë§ˆì°¬ê°€ì§€ë¡œ dequeueì¼ ë•Œ, ë©”ëª¨ë¦¬ ê³µê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ í™œìš©í•˜ê¸° ìœ„í•´ capacityë¥¼ ì ì ˆíˆ ì¡°ì ˆí•œë‹¤.
- ì´ë¥¼ ìœ„í•´ì„œ ìš”ì†Œê°€ ì „ì²´ capacityì˜ 1/4ë¡œ ì¤„ì–´ë“¤ë©´ í˜„ì¬ capacityë¥¼ 1/2 ë¡œ ê°ì†Œì‹œí‚¨ë‹¤. ë”°ë¼ì„œ dequeue ë©”ì„œë“œì— ê·¸ì™€ ê°™ì€ ì¡°ê±´ì„ ì¶”ê°€í•œë‹¤.  ( ArrayQueue class ì°¸ê³ .)

### 3.2 Implementing a Deque with a Circular Array

- ArrayQueue ì™€ êµ¬í˜„ë°©ì‹ì´ ê±°ì˜ ë¹„ìŠ·í•˜ë‹¤. _data, _size, _front instance variables ê°€ ì¡´ì¬í•˜ê³  front ë° back ì— ëŒ€í•´ì„œ í•„ìš”í• ë•Œë§ˆë‹¤ modular arithmetic ì—°ì‚°ì„ í•œë‹¤.
- ë§ˆì°¬ê°€ì§€ë¡œ dequeëŠ” backì˜ indexì™€ availableí•œ slotì´ ìˆëŠ”ì§€ ì•Œì•„ì•¼í•œë‹¤. last ë©”ì†Œë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ back ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•œë‹¤.

<aside>
ğŸ’¡ back = (self._front + self._size - 1 ) % len(self_data)

</aside>

<aside>
ğŸ’¡ self._front = (self._front - 1) % len(self._data)

</aside>

- ArrayDequeì˜ delete_first , add_lastëŠ” ê°ê° Queueì˜ dequeue, enqueue ì—°ì‚°ê³¼ ë™ì¼í•˜ë‹¤.

### 3.3 Deques in the Python Collections Module

- Pythonì—ì„œ ì œê³µí•˜ëŠ” collections.dequeëŠ” list classì™€ ë„¤ì´ë°ë„ ë¹„ìŠ·í•˜ê²Œ êµ¬í˜„ë˜ì—ˆê³ , D[j]ì™€ ê°™ì´ ì¸í…ìŠ¤ ê¸°ë°˜ì˜ ì ‘ê·¼ì„ í—ˆìš©í•œë‹¤.
- deque ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” maxlenì„ í†µí•´ì„œ ê³ ì •ëœ ì‚¬ì´ì¦ˆì˜ dequeë¥¼ ì œê³µí•œë‹¤.
- í˜„ì¬ collectionsì— ìˆëŠ” dequeì˜ ê²½ìš° circular arraysì™€ ë™ì‹œì— doubly linked list ë¡œ êµ¬ì„±ëœ blockë“¤ë¡œ êµ¬ì„±ì´ ë˜ì–´ìˆë‹¤.
- ì•„ë˜ëŠ” dequeì˜ ADTì™€ collections dequeì—ì„œ ì œê³µí•˜ëŠ” ëª¨ë“ˆë“¤ì„ ì†Œê°œí•œë‹¤.

![Untitled]({{site.url}}/images/lecture6/Untitled 4.png)

---

### ì—°ìŠµë¬¸ì œ

- í™€ìˆ˜ë²ˆ ë¬¸ì œ í’€ì´.

[DataStructureandAlgorithm/lecture6.py at master Â· kosohae/DataStructureandAlgorithm](https://github.com/kosohae/DataStructureandAlgorithm/blob/master/DSA/lecture6.py)
